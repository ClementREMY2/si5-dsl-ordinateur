/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Action = ActuatorAction | ScreenAction;

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export type Brick = BusBrick | PinBrick;

export const Brick = 'Brick';

export function isBrick(item: unknown): item is Brick {
    return reflection.isInstance(item, Brick);
}

export type BusBrick = Screen;

export const BusBrick = 'BusBrick';

export function isBusBrick(item: unknown): item is BusBrick {
    return reflection.isInstance(item, BusBrick);
}

export type PinBrick = Actuator | Sensor;

export const PinBrick = 'PinBrick';

export function isPinBrick(item: unknown): item is PinBrick {
    return reflection.isInstance(item, PinBrick);
}

export type PrimaryExpression = CompositeUnaryExpression | NestedExpression | SensorCondition | TemporalCondition;

export const PrimaryExpression = 'PrimaryExpression';

export function isPrimaryExpression(item: unknown): item is PrimaryExpression {
    return reflection.isInstance(item, PrimaryExpression);
}

export interface Actuator extends AstNode {
    readonly $container: App;
    readonly $type: 'Actuator';
    name: string
    outputPin: number
}

export const Actuator = 'Actuator';

export function isActuator(item: unknown): item is Actuator {
    return reflection.isInstance(item, Actuator);
}

export interface ActuatorAction extends AstNode {
    readonly $container: State;
    readonly $type: 'ActuatorAction';
    actuator: Reference<Actuator>
    value: Signal
}

export const ActuatorAction = 'ActuatorAction';

export function isActuatorAction(item: unknown): item is ActuatorAction {
    return reflection.isInstance(item, ActuatorAction);
}

export interface App extends AstNode {
    readonly $type: 'App';
    bricks: Array<Brick>
    initial: Reference<State>
    name: string
    states: Array<State>
}

export const App = 'App';

export function isApp(item: unknown): item is App {
    return reflection.isInstance(item, App);
}

export interface BinaryOperator extends AstNode {
    readonly $container: CompositeBinaryExpression;
    readonly $type: 'BinaryOperator';
    operator: 'and' | 'or'
}

export const BinaryOperator = 'BinaryOperator';

export function isBinaryOperator(item: unknown): item is BinaryOperator {
    return reflection.isInstance(item, BinaryOperator);
}

export interface Bus extends AstNode {
    readonly $container: Screen;
    readonly $type: 'Bus';
    value: string
}

export const Bus = 'Bus';

export function isBus(item: unknown): item is Bus {
    return reflection.isInstance(item, Bus);
}

export interface ComposableString extends AstNode {
    readonly $container: ComposableString | ScreenAction;
    readonly $type: 'ComposableString';
    actuator?: Reference<Actuator>
    next?: ComposableString
    sensor?: Reference<Sensor>
    string: string
}

export const ComposableString = 'ComposableString';

export function isComposableString(item: unknown): item is ComposableString {
    return reflection.isInstance(item, ComposableString);
}

export interface CompositeUnaryExpression extends AstNode {
    readonly $container: CompositeUnaryExpression | Expression;
    readonly $type: 'CompositeUnaryExpression';
    inner: PrimaryExpression
    operator: UnaryOperator
}

export const CompositeUnaryExpression = 'CompositeUnaryExpression';

export function isCompositeUnaryExpression(item: unknown): item is CompositeUnaryExpression {
    return reflection.isInstance(item, CompositeUnaryExpression);
}

export interface Expression extends AstNode {
    readonly $container: CompositeBinaryExpression | NestedExpression | Transition;
    readonly $type: 'CompositeBinaryExpression' | 'Expression';
    operand: PrimaryExpression
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface NestedExpression extends AstNode {
    readonly $container: CompositeUnaryExpression | Expression;
    readonly $type: 'NestedExpression';
    nested: Expression
}

export const NestedExpression = 'NestedExpression';

export function isNestedExpression(item: unknown): item is NestedExpression {
    return reflection.isInstance(item, NestedExpression);
}

export interface Screen extends AstNode {
    readonly $container: App;
    readonly $type: 'Screen';
    bus: Bus
    name: string
}

export const Screen = 'Screen';

export function isScreen(item: unknown): item is Screen {
    return reflection.isInstance(item, Screen);
}

export interface ScreenAction extends AstNode {
    readonly $container: State;
    readonly $type: 'ScreenAction';
    screen: Reference<Screen>
    value: ComposableString
}

export const ScreenAction = 'ScreenAction';

export function isScreenAction(item: unknown): item is ScreenAction {
    return reflection.isInstance(item, ScreenAction);
}

export interface Sensor extends AstNode {
    readonly $container: App;
    readonly $type: 'Sensor';
    inputPin: number
    name: string
}

export const Sensor = 'Sensor';

export function isSensor(item: unknown): item is Sensor {
    return reflection.isInstance(item, Sensor);
}

export interface SensorCondition extends AstNode {
    readonly $container: CompositeUnaryExpression | Expression;
    readonly $type: 'SensorCondition';
    sensor: Reference<Sensor>
    value: Signal
}

export const SensorCondition = 'SensorCondition';

export function isSensorCondition(item: unknown): item is SensorCondition {
    return reflection.isInstance(item, SensorCondition);
}

export interface Signal extends AstNode {
    readonly $container: ActuatorAction | SensorCondition;
    readonly $type: 'Signal';
    value: string
}

export const Signal = 'Signal';

export function isSignal(item: unknown): item is Signal {
    return reflection.isInstance(item, Signal);
}

export interface State extends AstNode {
    readonly $container: App;
    readonly $type: 'State';
    actions: Array<Action>
    name: string
    transitions: Array<Transition>
}

export const State = 'State';

export function isState(item: unknown): item is State {
    return reflection.isInstance(item, State);
}

export interface TemporalCondition extends AstNode {
    readonly $container: CompositeUnaryExpression | Expression;
    readonly $type: 'TemporalCondition';
    time: number
}

export const TemporalCondition = 'TemporalCondition';

export function isTemporalCondition(item: unknown): item is TemporalCondition {
    return reflection.isInstance(item, TemporalCondition);
}

export interface Transition extends AstNode {
    readonly $container: State;
    readonly $type: 'Transition';
    condition: Expression
    next: Reference<State>
}

export const Transition = 'Transition';

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition);
}

export interface UnaryOperator extends AstNode {
    readonly $container: CompositeUnaryExpression;
    readonly $type: 'UnaryOperator';
    operator: 'not'
}

export const UnaryOperator = 'UnaryOperator';

export function isUnaryOperator(item: unknown): item is UnaryOperator {
    return reflection.isInstance(item, UnaryOperator);
}

export interface CompositeBinaryExpression extends Expression {
    readonly $container: CompositeBinaryExpression | NestedExpression | Transition;
    readonly $type: 'CompositeBinaryExpression';
    operator: BinaryOperator
    rightOperand: Expression
}

export const CompositeBinaryExpression = 'CompositeBinaryExpression';

export function isCompositeBinaryExpression(item: unknown): item is CompositeBinaryExpression {
    return reflection.isInstance(item, CompositeBinaryExpression);
}

export interface ArduinoMlAstType {
    Action: Action
    Actuator: Actuator
    ActuatorAction: ActuatorAction
    App: App
    BinaryOperator: BinaryOperator
    Brick: Brick
    Bus: Bus
    BusBrick: BusBrick
    ComposableString: ComposableString
    CompositeBinaryExpression: CompositeBinaryExpression
    CompositeUnaryExpression: CompositeUnaryExpression
    Expression: Expression
    NestedExpression: NestedExpression
    PinBrick: PinBrick
    PrimaryExpression: PrimaryExpression
    Screen: Screen
    ScreenAction: ScreenAction
    Sensor: Sensor
    SensorCondition: SensorCondition
    Signal: Signal
    State: State
    TemporalCondition: TemporalCondition
    Transition: Transition
    UnaryOperator: UnaryOperator
}

export class ArduinoMlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Action', 'Actuator', 'ActuatorAction', 'App', 'BinaryOperator', 'Brick', 'Bus', 'BusBrick', 'ComposableString', 'CompositeBinaryExpression', 'CompositeUnaryExpression', 'Expression', 'NestedExpression', 'PinBrick', 'PrimaryExpression', 'Screen', 'ScreenAction', 'Sensor', 'SensorCondition', 'Signal', 'State', 'TemporalCondition', 'Transition', 'UnaryOperator'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Actuator:
            case Sensor: {
                return this.isSubtype(PinBrick, supertype);
            }
            case ActuatorAction:
            case ScreenAction: {
                return this.isSubtype(Action, supertype);
            }
            case CompositeUnaryExpression:
            case NestedExpression:
            case SensorCondition:
            case TemporalCondition: {
                return this.isSubtype(PrimaryExpression, supertype);
            }
            case Screen: {
                return this.isSubtype(BusBrick, supertype);
            }
            case CompositeBinaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case BusBrick:
            case PinBrick: {
                return this.isSubtype(Brick, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ActuatorAction:actuator':
            case 'ComposableString:actuator': {
                return Actuator;
            }
            case 'App:initial':
            case 'Transition:next': {
                return State;
            }
            case 'ComposableString:sensor':
            case 'SensorCondition:sensor': {
                return Sensor;
            }
            case 'ScreenAction:screen': {
                return Screen;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'App': {
                return {
                    name: 'App',
                    mandatory: [
                        { name: 'bricks', type: 'array' },
                        { name: 'states', type: 'array' }
                    ]
                };
            }
            case 'State': {
                return {
                    name: 'State',
                    mandatory: [
                        { name: 'actions', type: 'array' },
                        { name: 'transitions', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ArduinoMlAstReflection();
